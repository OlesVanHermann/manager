# PROMPT TARGET - Merge de Maquettes SVG (OLD + NEW â†’ TARGET)

## Fichiers et chemins

| Element | Valeur |
|---------|--------|
| **Prompt** | /home/ubuntu/prompt_target.txt |
| **Source OLD** | /mnt/user-data/uploads/old_manager_svg_{NAV1}_{NAV2}.tar |
| **Source NEW** | /mnt/user-data/uploads/new_manager_svg_{NAV1}_{NAV2}.tar |
| **Destination Claude (outputs)** | /mnt/user-data/outputs/target_svg/{NAV1}/{NAV2}/ |
| **Destination finale utilisateur** | /home/ubuntu/target_svg/{NAV1}/{NAV2}/ |

---

## âš ï¸ REGLES CRITIQUES - LIRE EN PREMIER âš ï¸

### REGLE 0 : PRINCIPES DE MERGE
Le TARGET est un **merge intelligent** entre OLD et NEW :

| Composant | Source | Raison |
|-----------|--------|--------|
| **Header OVH** | NEW | Design unifiÃ© |
| **Sidebar gauche** | NEW | Navigation moderne |
| **Breadcrumb (NAV1)** | NEW | UX cohÃ©rente |
| **Page Header (NAV2)** | NEW | Titre + sous-titre |
| **Tabs bar (NAV3)** | NEW | Structure tabs moderne |
| **Contenu des pages** | OLD | FonctionnalitÃ©s validÃ©es |
| **Cards/Tableaux** | OLD | DonnÃ©es mÃ©tier |
| **Actions/Boutons** | OLD | Logique existante |

### REGLE 1 : GENERATION DIRECTE OBLIGATOIRE
**INTERDICTION** d'afficher le SVG dans la conversation.

| âŒ INTERDIT | âœ… OBLIGATOIRE |
|-------------|----------------|
| Afficher le SVG brut | Ecrire avec `tee` dans `/mnt/user-data/outputs/` |
| "Voici le SVG, copiez-le..." | Appeler `present_files` apres generation |
| Attendre copier-coller | Fournir lien de telechargement |

### REGLE 2 : MAPPING FICHIERS OBLIGATOIRE
Avant tout merge, Ã©tablir le mapping OLDâ†”NEW :

| Status | Action |
|--------|--------|
| ğŸ”µ OLD + NEW existent | MERGE â†’ target_ |
| ğŸŸ¡ OLD seul | CONVERTIR (ajouter shell NEW) â†’ target_ |
| ğŸŸ¢ NEW seul | COPIER tel quel â†’ target_ |

### REGLE 3 : COHERENCE VISUELLE
Le TARGET doit Ãªtre visuellement cohÃ©rent :
- MÃªmes dimensions que NEW (1440px width)
- MÃªme positionnement du contenu
- Adapter le contenu OLD au layout NEW si nÃ©cessaire

---

## WORKFLOW OBLIGATOIRE

### Phase 1 : Extraction et inventaire
```bash
# 1. CrÃ©er workspace
mkdir -p /home/claude/work/{old_svg,new_svg,target_svg}

# 2. Extraire les archives
tar -xf /mnt/user-data/uploads/old_manager_svg_{NAV1}_{NAV2}.tar -C /home/claude/work/old_svg
tar -xf /mnt/user-data/uploads/new_manager_svg_{NAV1}_{NAV2}.tar -C /home/claude/work/new_svg

# 3. Lister et comparer
find /home/claude/work/old_svg -name "*.svg" | sort
find /home/claude/work/new_svg -name "*.svg" | sort
```

### Phase 2 : Etablir le mapping
```
=== MAPPING OLD â†” NEW ===

ğŸ”µ CORRESPONDANCES (merge requis) :
  old_.{page}.svg â†’ new_.{page}.svg â†’ target_.{page}.svg

ğŸŸ¡ OLD SEUL (conversion requise) :
  old_.{page}.svg â†’ target_.{page}.svg (avec shell NEW)

ğŸŸ¢ NEW SEUL (copie directe) :
  new_.{page}.svg â†’ target_.{page}.svg
```

### Phase 3 : Analyse comparative par fichier
Pour chaque paire OLD/NEW :
```bash
# Identifier les zones dans OLD
grep -E "(Card|Table|Content|g id=)" old_svg/{fichier}.svg

# Identifier les zones dans NEW  
grep -E "(sidebar|breadcrumb|tabs|header)" new_svg/{fichier}.svg
```

### Phase 4 : Generation TARGET
```bash
# 1. CrÃ©er arborescence outputs
mkdir -p /mnt/user-data/outputs/target_svg/{NAV1}/{NAV2}

# 2. Pour chaque fichier, gÃ©nÃ©rer le merge
tee /mnt/user-data/outputs/target_svg/{NAV1}/{NAV2}/target_.{NAV1}.{NAV2}.{page}.svg << 'EOFSVG'
<svg ...>
  <!-- SHELL FROM NEW : Header, Sidebar, Breadcrumb, Tabs structure -->
  <!-- CONTENT FROM OLD : Cards, Tables, Forms, Actions -->
</svg>
EOFSVG

# 3. Appeler present_files
```

### Phase 5 : Validation
```
âœ… TARGET gÃ©nÃ©rÃ© : target_.{NAV1}.{NAV2}.{page}.svg
   Source OLD : old_.{NAV1}.{NAV2}.{page}.svg
   Source NEW : new_.{NAV1}.{NAV2}.{page}.svg
   Merge : Shell NEW + Contenu OLD
```

---

## Convention de nommage

### Prefixes
| Prefix | Signification |
|--------|---------------|
| `old_` | Manager actuel (source contenu) |
| `new_` | Nouveau manager (source shell) |
| `target_` | **RÃ©sultat du merge** |

### Noms de fichiers TARGET
```
target_.{NAV1}.{NAV2}.svg                      # Page principale
target_.{NAV1}.{NAV2}.{section}.svg            # Section (hosting, private-database)
target_.{NAV1}.{NAV2}.{section}.tab-{nom}.svg  # Onglet spÃ©cifique
```

### Arborescence complete
```
/mnt/user-data/outputs/target_svg/
  â””â”€â”€ {NAV1}/
      â””â”€â”€ {NAV2}/
          â””â”€â”€ target_.{NAV1}.{NAV2}.{section}.svg
          â””â”€â”€ target_.{NAV1}.{NAV2}.{section}.tab-general.svg
          â””â”€â”€ target_.{NAV1}.{NAV2}.{section}.tab-ssl.svg
```

### Exemple concret
```
Input : 
  old_manager_svg_web-cloud_hebergement.tar
  new_manager_svg_web-cloud_hebergement.tar

Output :
/mnt/user-data/outputs/target_svg/web-cloud/hebergement/
  â””â”€â”€ target_.web-cloud.hebergement.hosting.svg
  â””â”€â”€ target_.web-cloud.hebergement.hosting.tab-general.svg
  â””â”€â”€ target_.web-cloud.hebergement.hosting.tab-ssl.svg
  â””â”€â”€ target_.web-cloud.hebergement.private-database.svg (copie NEW)
```

---

## Rapport de merge

```
=== CONTEXTE ===
NAV1 : {nav1}
NAV2 : {nav2}

=== MAPPING ===
ğŸ”µ MERGE (X fichiers) :
  - {page}.svg : OLD content + NEW shell
  - {page}.tab-{name}.svg : OLD content + NEW shell
  - ...

ğŸŸ¡ OLD SEUL (X fichiers) :
  - {page}.svg : Converti avec shell NEW
  - ...

ğŸŸ¢ NEW SEUL (X fichiers) :
  - {page}.svg : Copie directe
  - ...

=== TARGETS GENERES ===
1. âœ… target_.{NAV1}.{NAV2}.{page}.svg
2. âœ… target_.{NAV1}.{NAV2}.{page}.tab-{name}.svg
...
```

---

## Checklist finale

- [ ] Archives OLD et NEW extraites
- [ ] Mapping OLDâ†”NEW Ã©tabli
- [ ] Arborescence crÃ©Ã©e dans `/mnt/user-data/outputs/target_svg/`
- [ ] Pour chaque ğŸ”µ : merge Shell NEW + Contenu OLD
- [ ] Pour chaque ğŸŸ¡ : conversion avec Shell NEW
- [ ] Pour chaque ğŸŸ¢ : copie directe
- [ ] SVG Ã©crits avec `tee` (pas affichÃ©s)
- [ ] `present_files` appelÃ©
- [ ] CohÃ©rence visuelle vÃ©rifiÃ©e

---

## Gestion des cas spÃ©ciaux

### Contenu OLD trop large
Si le contenu OLD dÃ©passe la largeur main de NEW :
1. RÃ©duire les cards (3 â†’ 2 colonnes si nÃ©cessaire)
2. Ou adapter les largeurs proportionnellement

### Tabs diffÃ©rents OLD vs NEW
PrivilÃ©gier la structure tabs de NEW, mais :
- Si OLD a des tabs supplÃ©mentaires â†’ les ajouter
- Si OLD a des tabs manquants â†’ gÃ©nÃ©rer target_ quand mÃªme

### Styles incompatibles
Toujours utiliser les classes CSS de NEW pour uniformitÃ©.
