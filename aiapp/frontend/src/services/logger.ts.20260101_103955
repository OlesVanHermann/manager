// ============================================================
// LOGGER - Observabilité New Manager
// Capture: NAV changes, API calls, errors, actions
// Envoie vers /api/logs (nginx Lua)
// ============================================================

// ============ TYPES ============

type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'action' | 'api' | 'nav';

interface NavContext {
  nav1: string | null;  // activeUniverseId
  nav2: string | null;  // activeSectionId
  nav3: string | null;  // activeTabId
  service: string | null;  // selectedResource
}

interface LogEntry {
  ts: string;
  type: LogLevel;
  nav: NavContext;
  source: string;
  message: string;
  data?: unknown;
  api?: {
    method: string;
    endpoint: string;
    status: number;
    duration: number;
  };
  session: string;
  userId?: string;
}

// ============ SINGLETON ============

class Logger {
  private static instance: Logger;
  private buffer: LogEntry[] = [];
  private flushInterval = 3000;
  private flushTimer: ReturnType<typeof setInterval> | null = null;
  private session: string;
  private navContext: NavContext = { nav1: null, nav2: null, nav3: null, service: null };
  private endpoint = '/api/logs';
  private enabled = true;
  private userId: string | null = null;

  private constructor() {
    this.session = this.generateSessionId();
    this.setupFlush();
    this.setupGlobalErrorHandlers();
  }

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  private generateSessionId(): string {
    return `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 9)}`;
  }

  // ============ NAV CONTEXT ============

  setNav(nav: Partial<NavContext>) {
    const changed = 
      nav.nav1 !== this.navContext.nav1 ||
      nav.nav2 !== this.navContext.nav2 ||
      nav.nav3 !== this.navContext.nav3 ||
      nav.service !== this.navContext.service;
    
    this.navContext = { ...this.navContext, ...nav };
    
    if (changed) {
      this.logEntry('nav', 'nav', 'NAV_CHANGE', { ...this.navContext });
    }
  }

  getNav(): NavContext {
    return { ...this.navContext };
  }

  // ============ LOG METHODS ============

  private logEntry(level: LogLevel, source: string, message: string, data?: unknown, api?: LogEntry['api']) {
    if (!this.enabled) return;

    const entry: LogEntry = {
      ts: new Date().toISOString(),
      type: level,
      nav: { ...this.navContext },
      source,
      message,
      session: this.session,
    };

    if (this.userId) entry.userId = this.userId;
    if (data !== undefined) entry.data = data;
    if (api) entry.api = api;

    this.buffer.push(entry);

    // Flush immédiat pour les erreurs
    if (level === 'error') {
      this.flush();
    }
  }

  debug(source: string, message: string, data?: unknown) {
    this.logEntry('debug', source, message, data);
  }

  info(source: string, message: string, data?: unknown) {
    this.logEntry('info', source, message, data);
  }

  warn(source: string, message: string, data?: unknown) {
    this.logEntry('warn', source, message, data);
  }

  error(source: string, message: string, data?: unknown) {
    this.logEntry('error', source, message, data);
  }

  action(source: string, actionName: string, data?: unknown) {
    this.logEntry('action', source, actionName, data);
  }

  api(source: string, method: string, endpoint: string, status: number, duration: number) {
    this.logEntry('api', source, `${method} ${endpoint}`, undefined, {
      method,
      endpoint,
      status,
      duration,
    });
  }

  // ============ GLOBAL ERROR HANDLERS ============

  private setupGlobalErrorHandlers() {
    window.addEventListener('error', (event) => {
      this.logEntry('error', 'window', event.message, {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack,
      });
    });

    window.addEventListener('unhandledrejection', (event) => {
      const reason = event.reason;
      this.logEntry('error', 'promise', reason?.message || String(reason), {
        stack: reason?.stack,
      });
    });
  }

  // ============ FLUSH ============

  private setupFlush() {
    this.flushTimer = setInterval(() => this.flush(), this.flushInterval);
    window.addEventListener('beforeunload', () => this.flush());
    window.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') this.flush();
    });
  }

  async flush(): Promise<void> {
    if (this.buffer.length === 0 || !this.enabled) return;

    const logs = [...this.buffer];
    this.buffer = [];

    try {
      await fetch(this.endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ logs }),
        keepalive: true,
      });
    } catch {
      // Remettre les logs non envoyés (limité)
      this.buffer = [...logs.slice(-50), ...this.buffer.slice(-50)];
    }
  }

  // ============ CONFIG ============

  setEnabled(enabled: boolean) {
    this.enabled = enabled;
  }

  setUserId(id: string | null) {
    this.userId = id;
  }

  getUserId(): string | null {
    return this.userId;
  }

  getSession(): string {
    return this.session;
  }
}

// ============ EXPORTS ============

export const logger = Logger.getInstance();

// Helper pour créer un logger préfixé
export function createLogger(source: string) {
  return {
    debug: (msg: string, data?: unknown) => logger.debug(source, msg, data),
    info: (msg: string, data?: unknown) => logger.info(source, msg, data),
    warn: (msg: string, data?: unknown) => logger.warn(source, msg, data),
    error: (msg: string, data?: unknown) => logger.error(source, msg, data),
    action: (name: string, data?: unknown) => logger.action(source, name, data),
  };
}

// Raccourci global
export const log = {
  debug: (source: string, msg: string, data?: unknown) => logger.debug(source, msg, data),
  info: (source: string, msg: string, data?: unknown) => logger.info(source, msg, data),
  warn: (source: string, msg: string, data?: unknown) => logger.warn(source, msg, data),
  error: (source: string, msg: string, data?: unknown) => logger.error(source, msg, data),
  action: (source: string, name: string, data?: unknown) => logger.action(source, name, data),
  api: (source: string, method: string, endpoint: string, status: number, duration: number) => 
    logger.api(source, method, endpoint, status, duration),
  setNav: (nav: Partial<NavContext>) => logger.setNav(nav),
  getNav: () => logger.getNav(),
  setUserId: (id: string | null) => logger.setUserId(id),
  getUserId: () => logger.getUserId(),
};

export type { LogLevel, NavContext, LogEntry };
